---
layout: post
title: "《游戏编程模式》阅读小结"
date: 2018-08-17 16:43:29 +0800
category: read
typora-root-url: ..
---

　　多数游戏程序员所面临的最大挑战就是完成他们的游戏。许多游戏止步于其高度复杂的代码库面前，而最终没能问世。游戏编程设计模式正是为解决此问题而生。

![GameProgrammingPatterns](/images/GameProgrammingPatterns.jpg)

<!--more-->

- 抽象和解耦能够使得你的程序开发变得更快和更简单。但不要浪费时间来做这件事，除非你确信存在问题的代码需要这种灵活性。
- 在你的开发周期中要对性能进行思考和设计，但是要推迟那些降低灵活性的、底层的、详尽的优化，能晚则晚。
- 尽快地探索你的游戏的设计空间，但是不要走得太快留下一个烂摊子给自己。毕竟你将不得不面对它。
- 如果你将要删除代码，那么不要浪费时间将它整理得很整洁。摇滚明星把酒店房间弄得很乱是因为他们知道第二天就要结账走人。
- 但是，最重要的是，若要做一些有趣的玩意，那就乐在其中地做吧。

#### 设计模式

在《设计模式：可复用面向对象软件的基础》记载的几个最初的设计模式。

- **命令模式（Command Pattern）**：将一个请求（request）封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。
- **享元模式（Flyweight Pattern）**：使用共享以高效地支持大量的细粒度对象。
- **观察者模式（Observer Pattern）**：在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能收到通知并自动进行更新。
- **原型模式（Prototype Pattern）**：使用特定原型实例来创建特定种类的对象，并且通过拷贝原型来创建新的对象。
- **单例模式（Singleton Pattern）**：确保一个类只有一个实例，并为其提供一个全局访问入口。
- **状态模式（State Pattern）**：允许一个对象在其内部状态改变时改变自身的行为。对象看起来好像是在修改自身类。

#### 序列型模式（Sequencing Patterns）

- **双缓冲（Double Buffer）**：通过一系列顺序性的操作，使效果能够瞬时和同时的呈现出来。 

- **游戏循环（Game Loop）**：实现用户输入和处理器速度在游戏行进时间上的解耦。

- **更新方法（Update Method）**：通过对所有对象实例同时进行帧更新来模拟一系列相互独立的游戏对象。

#### 行为型模式（Behavioral Patterns）

- **字节码（Bytecode）**：通过将行为编码成虚拟机指令，而使其具备数据的灵活性。
- **子类沙盒（Subclass Sandbox）**：使用基类提供的操作集合来定义子类中的行为。
- **类型对象（Type Object）**：通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型。

#### 解耦型模式（Decoupling Patterns）

- **组件模式（Component）**：允许一个单一的实体跨越多个不同域而不会导致耦合。
- **事件队列（Event Queue）**：对消息或事件的发送与受理进行时间上的解耦。
- **服务定位器（Service Locator）**：为某服务提供一个全局访问入口来避免使用者与该服务具体实现类之间产生耦合。

#### 优化型模式（Optimization Patterns）

- **数据局部性（Data Locality）**：通过合理组织数据利用CPU的缓存机制来加快内存访问速度。
- **脏标记模式（Dirty Flag）**：将工作推迟到必要时进行以避免不必要的工作。
- **对象池（Object Pool）**：使用固定的对象池重用对象，取代单独地分配和释放对象，以此来达到提升性能和优化内存使用的目的。
- **空间分区（Spatial Partition）**：将对象存储在根据位置组织的数据结构中来高效地定位它们。